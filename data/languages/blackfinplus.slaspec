define endian=little;
define alignment=2;

define space ram type=ram_space size=4 default;
define space register type=register_space size=1;

# Data registers
define register offset=0x00 size=4
    [R0        R1        R2        R3       R4         R5        R6        R7];
define register offset=0x00 size=2
    [R0.L R0.H R1.L R1.H R2.L R2.H R3.L R3.H R4.L R4.H R5.L R5.H R6.L R6.H R7.L R7.H];
define register offset=0x00 size=1
    [R0.B _ _ _ R1.B _ _ _ R2.B _ _ _ R3.B _ _ _ R4.B _ _ _ R5.B _ _ _ R6.B _ _ _ R7.B];

# Pointer registers
define register offset=0x20 size=4 
    [P0        P1        P2        P3        P4        P5        SP        FP];
define register offset=0x20 size=2 
    [P0.L P0.H P1.L P1.H P2.L P2.H P3.L P3.H P4.L P4.H P5.L P5.H SP.L SP.H FP.L FP.H];

# Data address registers
define register offset=0x40 size=4 [
    I0        L0        B0        M0
    I1        L1        B1        M1
    I2        L2        B2        M2
    I3        L3        B3        M3
];
define register offset=0x40 size=2 [
    I0.L I0.H L0.L L0.H B0.L B0.H M0.L M0.H
    I1.L I1.H L1.L L1.H B1.L B1.H M1.L M1.H
    I2.L I2.H L2.L L2.H B2.L B2.H M2.L M2.H
    I3.L I3.H L3.L L3.H B3.L B3.H M3.L M3.H
];

# Accumulators (40 bit)
# A0.X and A1.X only contain 8 bit
define register offset=0x80 size=5 [ A0            A1 ];
define register offset=0x80 size=4 [ A0.W               ];
define register offset=0x85 size=4 [               A1.W ];
define register offset=0x80 size=1 [ _ _  _ _ A0.X _ _  _ _ A1.X ];
define register offset=0x80 size=2 [ A0.L A0.H                   ];
define register offset=0x85 size=2 [               A1.L A1.H     ];

# Status register and flags
define register offset=0x8a size=4 [
    ASTAT
];
define bitrange 
    AZ=ASTAT[0,1]
    AN=ASTAT[1,1]
    AC0COPY=ASTAT[2,1]
    VCOPY=ASTAT[3,1]
    CC=ASTAT[5,1]
    AQ=ASTAT[6,1]
    RND_MOD=ASTAT[8,1]
    AC0=ASTAT[12,1]
    AC1=ASTAT[13,1]
    AV0=ASTAT[16,1]
    AV0S=ASTAT[17,1]
    AV1=ASTAT[18,1]
    AV1S=ASTAT[19,1]
    V=ASTAT[24,1]
    VS=ASTAT[25,1]
;

# User Stack Pointer and EMUDAT
define register offset=0x90 size=4 [
    USP EMUDAT
];

define register offset=0x98 size=4 [
    PC
];

# Sequencer registers
define register offset=0xa0 size=4 [
    SEQSTAT
    RETX RETN RETI RETE RETS
    LC0 LC1 LT0 LT1 LB0 LB1
    SYSCFG
    CYCLES CYCLES2
];

define token inst16 (16)
    opcode04=(12,15)
    opcode05=(11,15)
    opcode06=(10,15)
    opcode07=(9,15)
    opcode08=(8,15)
    opcode10=(6,15)
    opcode11=(5,15)

# ALU2op Tokens
    alu2opOpc=(6,9)
    alu2opSrc=(3,5)
    alu2opSrcL=(3,5)
    alu2opSrcB=(3,5)
    alu2opDst=(0,2)
    alu2opDstCpy=(0,2)

# BrCC Tokens
    brccT=(11,11)
    brccB=(10,10)
    brccOff=(0,9)

# CC2Dreg Tokens
    cc2dregOpc=(3,4)
    cc2dregReg=(0,2)

# CC2Stat Tokens
    cc2statD=(7,7)
    cc2statOp=(5,6)
    cc2statCbit=(0,4)

# CCFlag Tokens
    ccflagI=(10,10)
    ccflagOpc=(7,9)
    ccflagG=(6,6)
    ccflagYDreg=(3,5)
    ccflagYPreg=(3,5)
    ccflagYImm=(3,5)
    ccflagXDreg=(0,2)
    ccflagXPreg=(0,2)

# CCMV Tokens
    ccmvT=(8,8)
    ccmvD=(7,7)
    ccmvS=(6,6)
    ccmvDstDreg=(3,5)
    ccmvDstPreg=(3,5)
    ccmvSrcDreg=(0,2)
    ccmvSrcPreg=(0,2)

# CacheCtrl Tokens
    cctrlA=(5,5)
    cctrlOpc=(3,4)
    cctrlReg=(0,2)

# CallA Tokens
    callaS=(8,8)
    callaSwH=(0,7)
;

define token inst32 (16)
# CallA Tokens
    callaSwL=(0,15)
;

# attach variables [ AllReg ] [
#     R0 R1 R2 R3 R4 R5 R6 R7
#     P0 P1 P2 P3 P4 P5 SP FP
#     I0 I1 I2 I3 M0 M1 M2 M3
#     B0 B1 B2 B3 L0 L1 L2 L3
#     A0.X A0.W A1.X A1.W _ _ ASTAT RETS
#     _  _  _  _  _  _  _  _
#     LC0 LT0 LB0 LC1 LT1 LB1 CYCLES CYCLES2
#     USP SEQSTAT SYSCFG RETI RETX RETN RETE EMUDAT
# ];

# attach variables [ AllReg5 ] [
#     R0 R1 R2 R3 R4 R5 R6 R7
#     P0 P1 P2 P3 P4 P5 SP FP
#     I0 I1 I2 I3 M0 M1 M2 M3
#     B0 B1 B2 B3 L0 L1 L2 L3
# ];

# attach variables [ AllReg5_lo ] [
#     R0.L R1.L R2.L R3.L R4.L R5.L R6.L R7.L
#     P0.L P1.L P2.L P3.L P4.L P5.L SP.L FP.L
#     I0.L I1.L I2.L I3.L M0.L M1.L M2.L M3.L
#     B0.L B1.L B2.L B3.L L0.L L1.L L2.L L3.L
# ];

# attach variables [ AllReg5_hi ] [
#     R0.H R1.H R2.H R3.H R4.H R5.H R6.H R7.H
#     P0.H P1.H P2.H P3.H P4.H P5.H SP.H FP.H
#     I0.H I1.H I2.H I3.H M0.H M1.H M2.H M3.H
#     B0.H B1.H B2.H B3.H L0.H L1.H L2.H L3.H
# ];

# Data registers
attach variables [ 
    alu2opSrc alu2opDst alu2opDstCpy
    cc2dregReg 
    ccflagYDreg ccflagXDreg
    ccmvDstDreg ccmvSrcDreg
] [
    R0 R1 R2 R3 R4 R5 R6 R7
];
attach variables [ alu2opSrcL ] [ R0.L R1.L R2.L R3.L R4.L R5.L R6.L R7.L];
# attach variables [ Dreg_h0 Dreg_h6 xreg0_h xreg3_h xreg6_h xreg9_h ] [ R0.H R1.H R2.H R3.H R4.H R5.H R6.H R7.H];
attach variables [ alu2opSrcB ] [ R0.B R1.B R2.B R3.B R4.B R5.B R6.B R7.B];

# Pointer registers
attach variables [ 
    ccflagYPreg ccflagXPreg 
    ccmvDstPreg ccmvSrcPreg
    cctrlReg
] [
    P0 P1 P2 P3 P4 P5 SP FP
];
# attach variables [ destreg_2 srcreg_2 ] [I0 I1 I2 I3 M0 M1 M2 M3];
# attach variables [ destreg_3 srcreg_3 ] [B0 B1 B2 B3 L0 L1 L2 L3];
# attach variables [ destreg_4 srcreg_4 ] [A0.X A0.W A1.X A1.W _ _ ASTAT RETS];
# #attach variables [ destreg_5 srcreg_5 ] []
# attach variables [ destreg_6 srcreg_6 ] [LC0 LT0 LB0 LC1 LT1 LB1 CYCLES CYCLES2];
# attach variables [ destreg_7 srcreg_7 ] [USP SEQSTAT SYSCFG RETI RETX RETN RETE EMUDAT];


## ALU Binary Operations (ALU2op)
##
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
## | 0 | 1 | 0 | 0 | 0 | 0 |.opc...........|.src.......|.dst.......|
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+

with : opcode06=0x10 {
:AShift32       alu2opDst ">>>=" alu2opSrc                    is alu2opOpc=0x0 & alu2opSrc & alu2opDst {}
:LShift         alu2opDst ">>=" alu2opSrc                     is alu2opOpc=0x1 & alu2opSrc & alu2opDst {}
:LShift         alu2opDst "<<=" alu2opSrc                     is alu2opOpc=0x2 & alu2opSrc & alu2opDst {}
:MultInt        alu2opDst *= alu2opSrc                        is alu2opOpc=0x3 & alu2opSrc & alu2opDst {}
:AddSubShift    alu2opDst = (alu2opSrc + alu2opDstCpy) "<< 1" is alu2opOpc=0x4 & alu2opSrc & alu2opDst & alu2opDstCpy {}
:AddSubShift    alu2opDst = (alu2opSrc + alu2opDstCpy) "<< 2" is alu2opOpc=0x5 & alu2opSrc & alu2opDst & alu2opDstCpy {}
:Divide         "divq" (alu2opDst, alu2opSrc)                 is alu2opOpc=0x8 & alu2opSrc & alu2opDst {}
:Divide         "divs" (alu2opDst, alu2opSrc)                 is alu2opOpc=0x9 & alu2opSrc & alu2opDst {}
:MvDregLToDreg  alu2opDst = alu2opSrcL "(X)"                  is alu2opOpc=0xa & alu2opSrcL & alu2opDst {}
:MvDregLToDreg  alu2opDst = alu2opSrcL "(Z)"                  is alu2opOpc=0xb & alu2opSrcL & alu2opDst {}
:MvDregBToDreg  alu2opDst = alu2opSrcB "(X)"                  is alu2opOpc=0xc & alu2opSrcB & alu2opDst {}
:MvDregBToDreg  alu2opDst = alu2opSrcB "(Z)"                  is alu2opOpc=0xd & alu2opSrcB & alu2opDst {}
:Neg32          alu2opDst = -alu2opSrc                        is alu2opOpc=0xe & alu2opSrc & alu2opDst {}
:Not32          alu2opDst = "~"alu2opSrc                      is alu2opOpc=0xf & alu2opSrc & alu2opDst {}
}


## Conditional Branch PC relative on CC (BrCC)
## 
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
## | 0 | 0 | 0 | 1 |.t.|.b.|.off.(imm10s2).........................|
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+

brccAddr: addr is brccOff [addr = inst_start + brccOff * 2;]{ export *[ram]:4 addr; }

with : opcode04=0x1 {
:BrCC "if !CC jump" brccAddr        is brccT=0x0 & brccB=0x0 & brccAddr {}
:BrCC "if !CC jump" brccAddr "(BP)" is brccT=0x0 & brccB=0x1 & brccAddr {}
:BrCC "if CC jump" brccAddr         is brccT=0x1 & brccB=0x0 & brccAddr {}
:BrCC "if CC jump" brccAddr "(BP)"  is brccT=0x1 & brccB=0x1 & brccAddr {}
}


## Move CC conditional bit, to and from Dreg (CC2Dreg)
##
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
## | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |.opc...|.reg.......|
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+

mvtoccDesc: "CC = !CC" is epsilon {}

with : opcode11=0x010 {
:CCToDreg cc2dregReg = "CC"  is cc2dregOpc=0x0 & cc2dregReg {}
:MvToCC   "CC" = cc2dregReg  is cc2dregOpc=0x1 & cc2dregReg {}
:CCToDreg cc2dregReg = "!CC" is cc2dregOpc=0x2 & cc2dregReg {}
:MvToCC   mvtoccDesc         is cc2dregOpc=0x3 & mvtoccDesc {}
}


## Copy CC conditional bit, from status (CC2Stat)
##
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
## | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |.d.|.op....|.cbit..............|
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+

CBIT: "AZ"      is cc2statCbit=0x00 {}
CBIT: "AN"      is cc2statCbit=0x01 {}
CBIT: "AQ"      is cc2statCbit=0x06 {}
CBIT: "RND_MOD" is cc2statCbit=0x08 {}
CBIT: "AC0"     is cc2statCbit=0x0c {}
CBIT: "AC1"     is cc2statCbit=0x0d {}
CBIT: "AV0"     is cc2statCbit=0x10 {}
CBIT: "AV0S"    is cc2statCbit=0x11 {}
CBIT: "AV1"     is cc2statCbit=0x12 {}
CBIT: "AV1S"    is cc2statCbit=0x13 {}
CBIT: "V"       is cc2statCbit=0x18 {}
CBIT: "VS"      is cc2statCbit=0x19 {}

with : opcode08=0x03 {
:MvToCC_STAT "CC =" CBIT  is cc2statD=0x0 & cc2statOp=0x0 & CBIT {}
:MvToCC_STAT "CC |=" CBIT is cc2statD=0x0 & cc2statOp=0x1 & CBIT {}
:MvToCC_STAT "CC &=" CBIT is cc2statD=0x0 & cc2statOp=0x2 & CBIT {}
:MvToCC_STAT "CC ^=" CBIT is cc2statD=0x0 & cc2statOp=0x3 & CBIT {}
:CCToStat16  CBIT "= CC"  is cc2statD=0x1 & cc2statOp=0x0 & CBIT {}
:CCToStat16  CBIT "|= CC" is cc2statD=0x1 & cc2statOp=0x1 & CBIT {}
:CCToStat16  CBIT "&= CC" is cc2statD=0x1 & cc2statOp=0x2 & CBIT {}
:CCToStat16  CBIT "^= CC" is cc2statD=0x1 & cc2statOp=0x3 & CBIT {}
}


## Set CC conditional bit (CCFlag)
##
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
## | 0 | 0 | 0 | 0 | 1 |.i.|.opc.......|.g.|.x.........|.y.........|
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+

with : opcode05=0x01 {
with : ccflagOpc=0x0 {
:CompRegisters "CC =" ccflagXDreg "==" ccflagYDreg is ccflagI=0x0 & ccflagG=0x0 & ccflagXDreg & ccflagYDreg {}
:CompRegisters "CC =" ccflagXDreg "==" ccflagYImm  is ccflagI=0x1 & ccflagG=0x0 & ccflagXDreg & ccflagYImm {}
:CCFlagP       "CC =" ccflagXPreg "==" ccflagYPreg is ccflagI=0x0 & ccflagG=0x1 & ccflagXPreg & ccflagYPreg {}
:CCFlagP       "CC =" ccflagXPreg "==" ccflagYImm  is ccflagI=0x1 & ccflagG=0x1 & ccflagXPreg & ccflagYImm {}
}

with : ccflagOpc=0x1 {
:CompRegisters "CC =" ccflagXDreg < ccflagYDreg is ccflagI=0x0 & ccflagG=0x0 & ccflagXDreg & ccflagYDreg {}
:CompRegisters "CC =" ccflagXDreg < ccflagYImm  is ccflagI=0x1 & ccflagG=0x0 & ccflagXDreg & ccflagYImm {}
:CCFlagP       "CC =" ccflagXPreg < ccflagYPreg is ccflagI=0x0 & ccflagG=0x1 & ccflagXPreg & ccflagYPreg {}
:CCFlagP       "CC =" ccflagXPreg < ccflagYImm  is ccflagI=0x1 & ccflagG=0x1 & ccflagXPreg & ccflagYImm {}
}

with : ccflagOpc=0x2 {
:CompRegisters "CC =" ccflagXDreg "<=" ccflagYDreg is ccflagI=0x0 & ccflagG=0x0 & ccflagXDreg & ccflagYDreg {}
:CompRegisters "CC =" ccflagXDreg "<=" ccflagYImm  is ccflagI=0x1 & ccflagG=0x0 & ccflagXDreg & ccflagYImm {}
:CCFlagP       "CC =" ccflagXPreg "<=" ccflagYPreg is ccflagI=0x0 & ccflagG=0x1 & ccflagXPreg & ccflagYPreg {}
:CCFlagP       "CC =" ccflagXPreg "<=" ccflagYImm  is ccflagI=0x1 & ccflagG=0x1 & ccflagXPreg & ccflagYImm {}
}

with : ccflagOpc=0x3 {
:CompRegisters "CC =" ccflagXDreg < ccflagYDreg "(IU)" is ccflagI=0x0 & ccflagG=0x0 & ccflagXDreg & ccflagYDreg {}
:CompRegisters "CC =" ccflagXDreg < ccflagYImm "(IU)"  is ccflagI=0x1 & ccflagG=0x0 & ccflagXDreg & ccflagYImm {}
:CCFlagP       "CC =" ccflagXPreg < ccflagYPreg "(IU)" is ccflagI=0x0 & ccflagG=0x1 & ccflagXPreg & ccflagYPreg {}
:CCFlagP       "CC =" ccflagXPreg < ccflagYImm "(IU)"  is ccflagI=0x1 & ccflagG=0x1 & ccflagXPreg & ccflagYImm {}
}

with : ccflagOpc=0x4 {
:CompRegisters "CC =" ccflagXDreg "<=" ccflagYDreg "(IU)" is ccflagI=0x0 & ccflagG=0x0 & ccflagXDreg & ccflagYDreg {}
:CompRegisters "CC =" ccflagXDreg "<=" ccflagYImm "(IU)"  is ccflagI=0x1 & ccflagG=0x0 & ccflagXDreg & ccflagYImm {}
:CCFlagP       "CC =" ccflagXPreg "<=" ccflagYPreg "(IU)" is ccflagI=0x0 & ccflagG=0x1 & ccflagXPreg & ccflagYPreg {}
:CCFlagP       "CC =" ccflagXPreg "<=" ccflagYImm "(IU)"  is ccflagI=0x1 & ccflagG=0x1 & ccflagXPreg & ccflagYImm {}
}

CompAccAux: "CC = A0 == A1" is ccflagOpc=0x5 {}
CompAccAux: "CC = A0 < A1"  is ccflagOpc=0x6 {}
CompAccAux: "CC = A0 <= A1" is ccflagOpc=0x7 {}

:CompAccumulators CompAccAux is CompAccAux {}
}


## Set CC conditional bit (CCFlag)
##
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
## | 0 | 0 | 0 | 0 | 0 | 1 | 1 |.t.|.d.|.s.|.dst.......|.src.......|
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+

GDST: ccmvDstDreg is ccmvD=0x0 & ccmvDstDreg {}
GDST: ccmvDstPreg is ccmvD=0x1 & ccmvDstPreg {}

GSRC: ccmvSrcDreg is ccmvS=0x0 & ccmvSrcDreg {}
GSRC: ccmvSrcPreg is ccmvS=0x1 & ccmvSrcPreg {}

with : opcode07=0x03 {
:MvRegToRegCond "if !CC" GDST = GSRC is ccmvT=0x0 & GDST & GSRC {}
:MvRegToRegCond "if CC" GDST = GSRC  is ccmvT=0x1 & GDST & GSRC {}
}


## Cache Control (CacheCtrl)
##
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
## | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 1 |.a.|.opc...|.reg.......|
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+

PREGA: cctrlReg   is cctrlA=0x0 & cctrlReg {}
PREGA: cctrlReg++ is cctrlA=0x1 & cctrlReg {}

with : opcode10=0x009 {
:CacheCtrl "prefetch" [PREGA] is cctrlOpc=0x0 & PREGA {}
:CacheCtrl "flushinv" [PREGA] is cctrlOpc=0x1 & PREGA {}
:CacheCtrl "flush" [PREGA]    is cctrlOpc=0x2 & PREGA {}
:CacheCtrl "iflush" [PREGA]   is cctrlOpc=0x3 & PREGA {}
}


## Call function with pcrel address (CallA)
##
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
## | 1 | 1 | 1 | 0 | 0 | 0 | 1 |.s.|.sw............................|
## |.sw.(imm24s2)..................................................|
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+

callaAddr: addr is callaSwH ; callaSwL [addr = inst_start + (callaSwH << 16 + callaSwL) * 2;]{ export *[ram]:4 addr; }

with : opcode07=0x71 ... {
:JumpAbs "jump.l" callaAddr is callaS=0x0 ... & callaAddr {}
:Call    "call" callaAddr   is callaS=0x1 ... & callaAddr {}
}
## Long Load/Store with indexed addressing (LdStExcl)
##
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
## | 1 | 1 | 1 | 0 | 1 | 1 |.w.|.z.|..sz...|....ptr....|....reg....|
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
## |.....................emotionalSupportBits......................|
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+

### Tokens ###

define token lseInstr16 (16)
	lseSig           = (10,15) 
	lseW             = ( 9, 9) 
	lseZ             = ( 8, 8) 
	lseSz            = ( 6, 7) 
	lsePtrPReg       = ( 3, 5) 
	lseRegDReg       = ( 0, 2) 
	lseRegDRegL      = ( 0, 2) 
	lseRegDRegH      = ( 0, 2) 
;

define token lseInstr32 (16)
	lseEmotionalSupportBits = ( 0,15) 
;


### Variables ###

attach variables lseRegDReg [R0 R1 R2 R3 R4 R5 R6 R7];
attach variables lseRegDRegL [R0.L R1.L R2.L R3.L R4.L R5.L R6.L R7.L];
attach variables lseRegDRegH [R0.H R1.H R2.H R3.H R4.H R5.H R6.H R7.H];
attach variables lsePtrPReg [P0 P1 P2 P3 P4 P5 SP FP];


### Operations ###

define pcodeop syncexcl;


### Instructions ###

LdStExcl:^"LdX32bitToDreg" lseRegDReg" = ["lsePtrPReg"] (EXCL)"
	is lseSig=0x3b & lseW=0x0 & lseZ=0x0 & lseSz=0x0 & lsePtrPReg & lseRegDReg 
	 ; lseEmotionalSupportBits 
{
	lseRegDReg = *[ram]:4 lsePtrPReg;
}

LdStExcl:^"LdX16bitToDreg" lseRegDReg" = W["lsePtrPReg"] (Z, EXCL)"
	is lseSig=0x3b & lseW=0x0 & lseZ=0x0 & lseSz=0x1 & lsePtrPReg & lseRegDReg 
	 ; lseEmotionalSupportBits 
{
	lseRegDReg = zext(*[ram]:2 lsePtrPReg);
}

LdStExcl:^"LdX16bitToDreg" lseRegDReg" = W["lsePtrPReg"] (X, EXCL)"
	is lseSig=0x3b & lseW=0x0 & lseZ=0x1 & lseSz=0x1 & lsePtrPReg & lseRegDReg 
	 ; lseEmotionalSupportBits 
{
	lseRegDReg = sext(*[ram]:2 lsePtrPReg);
}

LdStExcl:^"LdX08bitToDreg" lseRegDReg" = B["lsePtrPReg"] (Z, EXCL)"
	is lseSig=0x3b & lseW=0x0 & lseZ=0x0 & lseSz=0x2 & lsePtrPReg & lseRegDReg 
	 ; lseEmotionalSupportBits 
{
	lseRegDReg = zext(*[ram]:1 lsePtrPReg);
}

LdStExcl:^"LdX08bitToDreg" lseRegDReg" = B["lsePtrPReg"] (X, EXCL)"
	is lseSig=0x3b & lseW=0x0 & lseZ=0x1 & lseSz=0x2 & lsePtrPReg & lseRegDReg 
	 ; lseEmotionalSupportBits 
{
	lseRegDReg = sext(*[ram]:1 lsePtrPReg);
}

LdStExcl:^"LdX16bitToDregL" lseRegDRegL" = W["lsePtrPReg"] (EXCL)"
	is lseSig=0x3b & lseW=0x0 & lseZ=0x0 & lseSz=0x3 & lsePtrPReg & lseRegDRegL 
	 ; lseEmotionalSupportBits 
{
	lseRegDRegL = *[ram]:2 lsePtrPReg;
}

LdStExcl:^"LdX16bitToDregH" lseRegDRegH" = W["lsePtrPReg"] (EXCL)"
	is lseSig=0x3b & lseW=0x0 & lseZ=0x1 & lseSz=0x3 & lsePtrPReg & lseRegDRegH 
	 ; lseEmotionalSupportBits 
{
	lseRegDRegH = *[ram]:2 lsePtrPReg;
}

LdStExcl:^"StDregToX32bit" "CC = (["lsePtrPReg"] = "lseRegDReg") (EXCL)"
	is lseSig=0x3b & lseW=0x1 & lseZ=0x0 & lseSz=0x0 & lsePtrPReg & lseRegDReg 
	 ; lseEmotionalSupportBits 
{
	*[ram]:4 lsePtrPReg = lseRegDReg:4;
	CC = 0x1;
}

LdStExcl:^"StDregToX16bit" "CC = (W["lsePtrPReg"] = "lseRegDReg") (EXCL)"
	is lseSig=0x3b & lseW=0x1 & lseZ=0x0 & lseSz=0x1 & lsePtrPReg & lseRegDReg 
	 ; lseEmotionalSupportBits 
{
	*[ram]:2 lsePtrPReg = lseRegDReg:2;
	CC = 0x1;
}

LdStExcl:^"StDregToX08bit" "CC = (B["lsePtrPReg"] = "lseRegDReg") (EXCL)"
	is lseSig=0x3b & lseW=0x1 & lseZ=0x0 & lseSz=0x2 & lsePtrPReg & lseRegDReg 
	 ; lseEmotionalSupportBits 
{
	*[ram]:1 lsePtrPReg = lseRegDReg:1;
	CC = 0x1;
}

LdStExcl:^"StDregHToX16bit" "CC = (W["lsePtrPReg"] = "lseRegDRegH") (EXCL)"
	is lseSig=0x3b & lseW=0x1 & lseZ=0x0 & lseSz=0x3 & lsePtrPReg & lseRegDRegH 
	 ; lseEmotionalSupportBits 
{
	*[ram]:2 lsePtrPReg = lseRegDRegH:2;
	CC = 0x1;
}

LdStExcl:^"SyncExcl" 
	is lseSig=0x3b & lseW=0x1 & lseZ=0x1 & lseSz=0x3 & lsePtrPReg 
	 ; lseEmotionalSupportBits 
{
	syncexcl();
}



:^LdStExcl is LdStExcl { build LdStExcl; }

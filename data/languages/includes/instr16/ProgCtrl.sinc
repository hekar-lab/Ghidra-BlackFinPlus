## Basic Program Sequencer Control Functions (ProgCtrl)
##
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
## | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |......opc......|......reg......|
## +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+

### Tokens ###

define token pgcInstr16 (16)
	pgcSig           = ( 8,15) 
	pgcOpc           = ( 4, 7) 
	pgcReg           = ( 0, 3) 
	pgcRegUImm       = ( 0, 3) 
	pgcRegH          = ( 3, 3) 
	pgcRegLDReg      = ( 0, 2) 
	pgcRegLPReg      = ( 0, 2) 
;


### Variables ###

attach variables pgcRegLDReg [R0 R1 R2 R3 R4 R5 R6 R7];
attach variables pgcRegLPReg [P0 P1 P2 P3 P4 P5 SP FP];


### Operations ###

define pcodeop idle;
define pcodeop csync;
define pcodeop ssync;
define pcodeop emuexcpt;
define pcodeop raise;
define pcodeop excpt;


### Instructions ###

ProgCtrlDesc00: "RTS" is epsilon {}
ProgCtrl:^"Return" ProgCtrlDesc00
	is ProgCtrlDesc00 & pgcSig=0x00 & pgcOpc=0x1 & pgcReg=0x0 
{
	return [RETS];
}

ProgCtrlDesc01: "RTI" is epsilon {}
ProgCtrl:^"Return" ProgCtrlDesc01
	is ProgCtrlDesc01 & pgcSig=0x00 & pgcOpc=0x1 & pgcReg=0x1 
{
	return [RETI];
}

ProgCtrlDesc02: "RTX" is epsilon {}
ProgCtrl:^"Return" ProgCtrlDesc02
	is ProgCtrlDesc02 & pgcSig=0x00 & pgcOpc=0x1 & pgcReg=0x2 
{
	return [RETX];
}

ProgCtrlDesc03: "RTN" is epsilon {}
ProgCtrl:^"Return" ProgCtrlDesc03
	is ProgCtrlDesc03 & pgcSig=0x00 & pgcOpc=0x1 & pgcReg=0x3 
{
	return [RETN];
}

ProgCtrlDesc04: "RTE" is epsilon {}
ProgCtrl:^"Return" ProgCtrlDesc04
	is ProgCtrlDesc04 & pgcSig=0x00 & pgcOpc=0x1 & pgcReg=0x4 
{
	return [RETE];
}

ProgCtrlDesc05: "IDLE" is epsilon {}
ProgCtrl:^"Sync" ProgCtrlDesc05
	is ProgCtrlDesc05 & pgcSig=0x00 & pgcOpc=0x2 & pgcReg=0x0 
{
	idle();
}

ProgCtrlDesc06: "CSYNC" is epsilon {}
ProgCtrl:^"Sync" ProgCtrlDesc06
	is ProgCtrlDesc06 & pgcSig=0x00 & pgcOpc=0x2 & pgcReg=0x3 
{
	csync();
}

ProgCtrlDesc07: "SSYNC" is epsilon {}
ProgCtrl:^"Sync" ProgCtrlDesc07
	is ProgCtrlDesc07 & pgcSig=0x00 & pgcOpc=0x2 & pgcReg=0x4 
{
	ssync();
}

ProgCtrlDesc08: "EMUEXCPT" is epsilon {}
ProgCtrl:^"Mode" ProgCtrlDesc08
	is ProgCtrlDesc08 & pgcSig=0x00 & pgcOpc=0x2 & pgcReg=0x5 
{
	emuexcpt();
}

ProgCtrl:^"IMaskMv" "CLI "pgcRegLDReg
	is pgcSig=0x00 & pgcOpc=0x3 & pgcRegH=0x0 & pgcRegLDReg 
{
	local imaskAddr:4 = 0x1FC02104;
	pgcRegLDReg = *[ram]:4 imaskAddr;
	*[ram]:4 imaskAddr = 0x0;
}

ProgCtrl:^"IMaskMv" "STI "pgcRegLDReg
	is pgcSig=0x00 & pgcOpc=0x4 & pgcRegH=0x0 & pgcRegLDReg 
{
	local imaskAddr:4 = 0x1FC02104;
	*[ram]:4 imaskAddr = pgcRegLDReg;
}

ProgCtrl:^"Jump" "JUMP ("pgcRegLPReg")"
	is pgcSig=0x00 & pgcOpc=0x5 & pgcRegH=0x0 & pgcRegLPReg 
{
	goto [pgcRegLPReg];
}

ProgCtrl:^"Jump" "JUMP (PC + "pgcRegLPReg")"
	is pgcSig=0x00 & pgcOpc=0x8 & pgcRegH=0x0 & pgcRegLPReg 
{
	goto [pgcRegLPReg + PC];
}

ProgCtrl:^"Call" "CALL ("pgcRegLPReg")"
	is pgcSig=0x00 & pgcOpc=0x6 & pgcRegH=0x0 & pgcRegLPReg 
{
	RETS = inst_next;
	call [pgcRegLPReg];
}

ProgCtrl:^"Call" "CALL (PC + "pgcRegLPReg")"
	is pgcSig=0x00 & pgcOpc=0x7 & pgcRegH=0x0 & pgcRegLPReg 
{
	RETS = inst_next;
	call [pgcRegLPReg + PC];
}

ProgCtrl:^"Raise" "RAISE "pgcRegUImm
	is pgcSig=0x00 & pgcOpc=0x9 & pgcRegUImm 
{
	raise(pgcRegUImm:1);
}

ProgCtrl:^"Raise" "EXCPT "pgcRegUImm
	is pgcSig=0x00 & pgcOpc=0xa & pgcRegUImm 
{
	excpt(pgcRegUImm:1);
}

ProgCtrl:^"TestSet" "TESTSET ("pgcRegLPReg")"
	is pgcSig=0x00 & pgcOpc=0xb & pgcRegH=0x0 & pgcRegLPReg 
{
	local testVal:1 = *[ram]:1 pgcRegLPReg;
	CC = 0x0;
	if (testVal != 0x0) goto <is_set>;
	CC = 0x1;
<is_set>
	*[ram]:1 pgcRegLPReg = testVal | 0x80;
}

ProgCtrl:^"Sync" "STI IDLE "pgcRegLDReg
	is pgcSig=0x00 & pgcOpc=0xc & pgcRegH=0x0 & pgcRegLDReg 
{
	local imaskAddr:4 = 0x1FC02104;
	*[ram]:4 imaskAddr = pgcRegLDReg;
	idle();
}



:^ProgCtrl is ProgCtrl { build ProgCtrl; }
